/*!
 * pixi-lights - v2.0.2
 * Compiled Sat, 23 Feb 2019 21:47:53 UTC
 *
 * pixi-lights is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t.PIXI=t.PIXI||{},t.PIXI.lights={}))}(this,function(t){"use strict";PIXI.Circle.prototype.getMesh=function(t,e,r){void 0===t&&(t=40),e=e||new Float32Array(2*(t+1)),r=r||new Uint16Array(t+1);var i=2*Math.PI/t,o=-1;r[++o]=o;for(var n=0;n<=t;++n){var a=2*n,s=i*n;e[a]=Math.cos(s)*this.radius,e[a+1]=Math.sin(s)*this.radius,r[++o]=o}return r[o]=1,{vertices:e,indices:r}};var e={},r=new PIXI.display.Group,i=new PIXI.display.Group,o=new PIXI.display.Group;function n(t,r){e[t]=r}r.useRenderTexture=!0,i.useRenderTexture=!0;var a=function(t){function e(e,r,i,n){t.call(this),this.vertices=i||new Float32Array(8),this.indices=n||new Uint16Array([0,1,2,0,2,3]),this.blendMode=PIXI.BLEND_MODES.ADD,this.drawMode=PIXI.DRAW_MODES.TRIANGLES,this.dirty=0,this.lightHeight=.075,this.falloff=[.75,3,20],this.shaderName=null,this.useViewportQuad=!0,this._color=5066073,this._colorRgba=[.3,.3,.35,.8],(e||0===e)&&(this.color=e),(r||0===r)&&(this.brightness=r),this.parentGroup=o,this._glDatas={},this.shaderName="lights"}t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e;var r={color:{configurable:!0},brightness:{configurable:!0}};return r.color.get=function(){return this._color},r.color.set=function(t){this._color=t,PIXI.utils.hex2rgb(t,this._colorRgba)},r.brightness.get=function(){return this._colorRgba[3]},r.brightness.set=function(t){this._colorRgba[3]=t},e.prototype.syncShader=function(t){t.uniforms.uUseViewportQuad=this.useViewportQuad;var e=t.uniforms.uLightColor;e&&(e[0]=this._colorRgba[0],e[1]=this._colorRgba[1],e[2]=this._colorRgba[2],e[3]=this._colorRgba[3],t.uniforms.uLightColor=e),t.uniforms.uLightHeight=this.lightHeight;var r=t.uniforms.uLightFalloff;r&&(r[0]=this.falloff[0],r[1]=this.falloff[1],r[2]=this.falloff[2],t.uniforms.uLightFalloff=r)},e.prototype._renderWebGL=function(t){t.setObjectRenderer(t.plugins.lights),t.plugins.lights.render(this)},Object.defineProperties(e.prototype,r),e}(PIXI.Container),s=function(t){function e(r,i,o,n,a){var s={translationMatrix:{type:"mat3",value:new Float32Array(9)},projectionMatrix:{type:"mat3",value:new Float32Array(9)},uSampler:{type:"sampler2D",value:null},uNormalSampler:{type:"sampler2D",value:null},uUseViewportQuad:{type:"bool",value:!0},uViewSize:{type:"2f",value:new Float32Array(2)},uViewPixels:{type:"2f",value:new Float32Array(2)},uLightColor:{type:"4f",value:new Float32Array([1,1,1,1])},uLightFalloff:{type:"3f",value:new Float32Array([0,0,0])},uLightHeight:{type:"1f",value:.075}};if(n)for(var l in n)s[l]=n[l];var u={aVertexPosition:0};if(a)for(var h in a)u[h]=a[h];t.call(this,r,i||e.defaultVertexSrc,o,u)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(PIXI.Shader);s.defaultVertexSrc="attribute vec2 aVertexPosition;\r\n\r\nuniform bool uUseViewportQuad;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 projectionMatrix;\r\n\r\nvoid main(void) {\r\n    if (uUseViewportQuad) {\r\n        gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    }\r\n    else\r\n    {\r\n        gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    }\r\n}\r\n";var l=function(t){function e(e,r){void 0===e&&(e=16777215),void 0===r&&(r=.5),t.call(this,e,r),this.shaderName="ambientLightShader"}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(a),u="uniform sampler2D uSampler;\nuniform sampler2D uNormalSampler;\n\nuniform mat3 translationMatrix;\n\nuniform vec2 uViewPixels;   // size of the viewport, in pixels\nuniform vec2 uViewSize;     // size of the viewport, in CSS\n\nuniform vec4 uLightColor;   // light color, alpha channel used for intensity.\nuniform vec3 uLightFalloff; // light attenuation coefficients (constant, linear, quadratic)\nuniform float uLightHeight; // light height above the viewport\nuniform float uFlipY;             // whether we use renderTexture, FBO is flipped\n",h="vec2 texCoord = gl_FragCoord.xy / uViewPixels;\ntexCoord.y = (1.0 - texCoord.y) * uFlipY + texCoord.y * (1.0 - uFlipY); // FBOs positions are flipped.\n",c="vec4 normalColor = texture2D(uNormalSampler, texCoord);\r\nnormalColor.g = 1.0 - normalColor.g; // Green layer is flipped Y coords.\r\n\r\n// bail out early when normal has no data\r\nif (normalColor.a == 0.0) discard;\r\n",f="precision highp float;\n\n"+u+"\n\nvoid main(void)\n{\n"+h+"\n"+c+"\n    // simplified lambert shading that makes assumptions for ambient color\n    vec3 diffuse = uLightColor.rgb * uLightColor.a;\n    vec4 diffuseColor = texture2D(uSampler, texCoord);\n    vec3 finalColor = diffuseColor.rgb * diffuse;\n    \n    gl_FragColor = vec4(finalColor, diffuseColor.a);\n}\n",d=function(t){function e(e){t.call(this,e,null,f)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(s);n("ambientLightShader",d);var p=function(t){function e(e,r,i){if(void 0===e&&(e=16777215),void 0===r&&(r=1),void 0===i&&(i=1/0),i!==1/0){var o=new PIXI.Circle(0,0,i).getMesh(),n=o.vertices,a=o.indices;t.call(this,e,r,n,a),this.useViewportQuad=!1,this.drawMode=PIXI.DRAW_MODES.TRIANGLE_FAN}else t.call(this,e,r);this.radius=i,this.shaderName="pointLightShader"}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.syncShader=function(e){t.prototype.syncShader.call(this,e),e.uniforms.uLightRadius=this.radius},e}(a),g='// normalize vectors\r\nvec3 N = normalize(normalColor.xyz * 2.0 - 1.0);\r\nvec3 L = normalize(lightVector);\r\n\r\n// pre-multiply light color with intensity\r\n// then perform "N dot L" to determine our diffuse\r\nvec3 diffuse = (uLightColor.rgb * uLightColor.a) * max(dot(N, L), 0.0);\r\n',v="// calculate final intesity and color, then combine\r\nvec3 intensity = diffuse * attenuation;\r\nvec4 diffuseColor = texture2D(uSampler, texCoord);\r\nvec3 finalColor = diffuseColor.rgb * intensity;\r\n\r\ngl_FragColor = vec4(finalColor, diffuseColor.a);\r\n",y="precision highp float;\n\n// imports the common uniforms like samplers, and ambient color\n"+u+"\n\nuniform float uLightRadius;\n\nvoid main()\n{\n"+h+"\n"+c+"\n\n    vec2 lightPosition = translationMatrix[2].xy / uViewSize;\n\n    // the directional vector of the light\n    vec3 lightVector = vec3(lightPosition - texCoord, uLightHeight);\n\n    // correct for aspect ratio\n    lightVector.x *= uViewSize.x / uViewSize.y;\n\n    // compute Distance\n    float D = length(lightVector);\n\n    // bail out early when pixel outside of light sphere\n    if (D > uLightRadius) discard;\n\n"+g+"\n\n    // calculate attenuation\n    float attenuation = 1.0 / (uLightFalloff.x + (uLightFalloff.y * D) + (uLightFalloff.z * D * D));\n\n"+v+"\n}\n",m=function(t){function e(e){t.call(this,e,null,y,{uLightRadius:{type:"1f",value:1}})}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(s);n("pointLightShader",m);var _=function(t){function e(e,r,i){void 0===e&&(e=16777215),void 0===r&&(r=1),t.call(this,e,r),this.target=i,this._directionVector=new PIXI.Point,this.shaderName="directionalLightShader"}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.updateTransform=function(){this.containerUpdateTransform();var t=this._directionVector,e=this.worldTransform,r=this.target.worldTransform?this.target.worldTransform.tx:this.target.x,i=this.target.worldTransform?this.target.worldTransform.ty:this.target.y;t.x=e.tx-r,t.y=e.ty-i;var o=Math.sqrt(t.x*t.x+t.y*t.y);t.x/=o,t.y/=o},e.prototype.syncShader=function(e){t.prototype.syncShader.call(this,e);var r=e.uniforms.uLightDirection;r[0]=this._directionVector.x,r[1]=this._directionVector.y,e.uniforms.uLightDirection=r},e}(a),x="precision highp float;\n\n// imports the common uniforms like samplers, and ambient/light color\n"+u+"\n\nuniform vec2 uLightDirection;\n\nvoid main()\n{\n"+h+"\n"+c+"\n\n    // the directional vector of the light\n    vec3 lightVector = vec3(uLightDirection, uLightHeight);\n\n    // compute Distance\n    float D = length(lightVector);\n\n"+g+"\n\n    // calculate attenuation\n    float attenuation = 1.0;\n\n"+v+"\n}\n",b=function(t){function e(e){t.call(this,e,null,x,{uLightDirection:{type:"2f",value:new Float32Array(2)}})}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(s);n("directionalLightShader",b);var w=function(t){function o(e){t.call(this,e);var r=6*o.MAX_LIGHTS;this.indices=new Uint16Array(r);for(var i=0,n=0;i<r;i+=6,n+=4)this.indices[i+0]=n+0,this.indices[i+1]=n+1,this.indices[i+2]=n+2,this.indices[i+3]=n+0,this.indices[i+4]=n+2,this.indices[i+5]=n+3;this.shaders={},this.lights=[]}return t&&(o.__proto__=t),o.prototype=Object.create(t&&t.prototype),o.prototype.constructor=o,o.prototype.onContextChange=function(){for(var t in this.gl=this.renderer.gl,e)this.shaders[t]=new e[t](this.gl)},o.prototype.render=function(t){var e=this.renderer,r=e.gl;this.lights.push(t);var i=t._glDatas[e.CONTEXT_UID];i||(e.bindVao(null),(i={shader:this.shaders[t.shaderName],vertexBuffer:PIXI.glCore.GLBuffer.createVertexBuffer(r,t.vertices,r.STREAM_DRAW),indexBuffer:PIXI.glCore.GLBuffer.createIndexBuffer(r,t.indices,r.STATIC_DRAW),vao:null,dirty:t.dirty}).vao=new PIXI.glCore.VertexArrayObject(r).addIndex(i.indexBuffer).addAttribute(i.vertexBuffer,i.shader.attributes.aVertexPosition,r.FLOAT,!1,8,0),t._glDatas[e.CONTEXT_UID]=i),e.bindVao(i.vao),t.useViewportQuad&&(t.vertices[2]=t.vertices[4]=e.screen.width,t.vertices[5]=t.vertices[7]=e.screen.height),i.vertexBuffer.upload(t.vertices),i.dirty!==t.dirty&&(i.dirty=t.dirty,i.indexBuffer.upload(t.indices))},o.prototype.flush=function(){for(var t=null,e=null,o=null,n=null,a=this.renderer,s=0;s<this.lights.length;++s){var l=this.lights[s],u=this.lights[s]._activeParentLayer;if(u){if(o!==u){o=u;var h=u._activeStageParent;if(u.diffuseTexture&&u.normalTexture)t=u.diffuseTexture,e=u.normalTexture;else for(var c=0;c<h._activeLayers.length;c++){var f=h._activeLayers[c];f.group===i&&(e=f.getRenderTexture()),f.group===r&&(t=f.getRenderTexture())}a.bindTexture(t,0,!0),a.bindTexture(e,1,!0)}var d=l._glDatas[a.CONTEXT_UID],p=d.shader;if(n!==p){n=p,a.bindShader(p),p.uniforms.uSampler=0,p.uniforms.uNormalSampler=1;var g=p.uniforms.uViewSize;g&&(g[0]=a.screen.width,g[1]=a.screen.height,p.uniforms.uViewSize=g);var v=p.uniforms.uViewPixels;v&&(v[0]=a.view.width,v[1]=a.view.height,p.uniforms.uViewPixels=v),p.uniforms.uFlipY=a._activeRenderTarget.root?1:0}a.bindVao(d.vao),l.syncShader(p),a.state.setBlendMode(l.blendMode),p.uniforms.translationMatrix=l.worldTransform.toArray(!0),d.vao.draw(l.drawMode,l.indices.length,0)}}this.lights.length=0},o.prototype.stop=function(){this.flush()},o}(PIXI.ObjectRenderer);w.MAX_LIGHTS=500,PIXI.WebGLRenderer.registerPlugin("lights",w);var L="attribute vec2 aVertexPosition;\r\nuniform mat3 projectionMatrix;\r\n\r\nvoid main(void) {\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n}",I="void main() {\r\n    gl_FragColor = vec4(0, 0, 0, 1);\r\n}",S=function(t){function e(e){t.call(this,e,L,I,{aVertexPosition:0})}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(PIXI.Shader);n("wireframeShader",S),t.Light=a,t.LightShader=s,t.AmbientLight=l,t.AmbientLightShader=d,t.PointLight=p,t.PointLightShader=m,t.DirectionalLight=_,t.DirectionalLightShader=b,t.LightRenderer=w,t.WireframeShader=S,t.plugins=e,t.diffuseGroup=r,t.normalGroup=i,t.lightGroup=o,t.registerPlugin=n,Object.defineProperty(t,"__esModule",{value:!0})});
//# sourceMappingURL=pixi-lights.js.map
